---
title: Storage System 存储系统(一)
date: 2020-04-29 00:12:43
tags: Knowledge points
categories: Computer Organization
postImage: https://s1.ax1x.com/2020/04/29/JoQHUg.jpg
---

存储系统是指计算机中由存放程序和数据的各种存储设备、控制部件及管理信息调度的设备（硬件）和算法（软件）所组成的系统。计算机的主存储器不能同时满足存取速度快、存储容量大和成本低的要求，在计算机中必须有速度由慢到快、容量由大到小的多级层次存储器，以最优的控制调度算法和合理的成本，构成具有性能可接受的存储系统。

<!--more-->

## 存储系统层次结构

### 基本存储体系

原理

存储程序 （主存）

- 输入设备将程序与数据写入主存
- CPU取指令
- CPU执行指令期间读数据
- CPU写回运算结果
- 输出设备输出结果

程序控制（CPU）

![img](https://s1.ax1x.com/2020/04/29/JoJn4U.png)

### 主存速度慢的原因

![img](https://s1.ax1x.com/2020/04/29/JoJHaV.png)

- 主存增速与CPU增速不同
- 指令执行期间多次访问存储器

### 主存容量不足的原因

- 存在制约主存容量的技术因素 (由CPU、主板等相关技术指标确定)
- 应用对主存的需求不断扩大

### 存储体系的层次化结构

![img](https://s1.ax1x.com/2020/04/29/JodEDJ.png)

![img](https://s1.ax1x.com/2020/04/29/JodN5t.png)

CPU访问到的存储系统具有Cache的速度，辅存的容量和价格

高速缓存又分为两部分

![img](https://s1.ax1x.com/2020/04/29/JoDawQ.png)

- L1 Cache集成在CPU中，分数据Cache(D-Cache)和指令Cache(I-Cache)
- 早期L2 Cache在主板上或与CPU集成在同一电路板上。随着工艺的提高L2Cache被集成在CPU内核中，不分D-Cache和I-Cache

### 存储体系层次化结构的理论基础

局部性原理

![img](https://s1.ax1x.com/2020/04/29/JTpOtU.png)

- 时间局部性: 现在被访问的信息2在不久的将来还将再次被访问

  时间局部性的程序结构体现：**循环结构**

- 空间局部性：现访问信息2 ，下一次访问2附近的信息。

  空间局部性的程序结构体现：**顺序结构**

## 主存中的数据组织

### 存储字长

- 主存的一个存储单元所包含的二进制位数
- 目前大多数计算机的主存按字节编址，存储字长也不断加大,如16位字长、32位字长和64位字长
- ISA设计时要考虑的两个问题：
  - 如何根据字节地址读取一个32位的字？ - 字的存放问题
  - 一个字能否存放在主存的任何字节边界？ - 字的边界对齐问题

### 数据存储与边界的关系

1. 按边界对齐的数据存储

边界也分好几种:字节边界,字边界,双字边界,半字长边界.

int i(32位), short k(16位), double x(64位), char c(8位), short j,…… （32位系统中）

![img](https://s1.ax1x.com/2020/04/29/JT9AhD.png)

边界存放可能会导致部分空间的浪费.

1. 未按边界对齐的数据存储

![img](https://s1.ax1x.com/2020/04/29/JTCyIf.png)

虽节省了空间，但增加了访存次数！需要在性能与容量间权衡！

比如要访问x,则需要访问三次,而刚才只需要访问两次.所以这个是用性能换空间.

1. 边界对齐与存储地址的关系(以32位为例)

- 双字长数据边界对齐的起始地址的最末三位为000(8字节整数倍)

  双字长是64位,即八个字节,计算机中主存按字节,所以是八字节的整数倍.

- 单字长边界对齐的起始地址的末二位为00(4字节整数倍)

- 半字长边界对齐的起始地址的最末一位为0(２字节整数倍)

1. 对齐情况下，哪种结构声明更好（32位为例）

   ![img](https://s1.ax1x.com/2020/04/30/JL3KDH.png)

   ![img](https://s1.ax1x.com/2020/04/30/JL8Zon.png)

   ![img](https://s1.ax1x.com/2020/04/30/JL8UW6.png)

   如果每个只有一个的话，是第一种结构更好，但是如果是多维数组的话，两种方式没什么区别，因为都有浪费的地方。

### 大端与小端存储方式

- Big-endian：最高字节地址(MSB)是数据地址

  ![img](https://s1.ax1x.com/2020/04/30/JLYMSP.png)

- Big-endian: 最高字节地址(MSB)是数据地址

  ![img](https://s1.ax1x.com/2020/04/30/JLYdS0.png)

设某程序执行前 r0 = 0x 11223344，执行下列指令：

```
r1 = 0x100
// 将r0中的内容放在r1的内容所指向的储存单元
STR r0, [r1]
// r1对应的组成单元取一个字节送到r2
LDRB r2, [r1]
```

小端模式下：r2=0x44

大选模式下：r2=0x11

无论是大端还是小端，每个系统内部是一致的，但在系统间通信时可能会发生问题！因为顺序不同，需要进行顺序转换；

## 静态存储器工作原理

任何存储器都是由存储单元按照某种模式组合起来的。

### SRAM存储单元结构

#### 6管静态存储单元

![img](https://s1.ax1x.com/2020/04/29/JoZKL4.png)

- 工作管：$T_1, T_2$（保存数据）通过构成的稳定互锁状态来保存信息
- 负载管：$T_3, T_4$（补充电荷）为工作管提供工作电流
- 门控管：$T_5, T_6,T_7, T_8$（开关作用）控制存储单元与外界的通断

当X地址选通时（行选通）

- X通电导致$T_5, T_6$门控管被打开（饱和导通状态）
- A点与位线相连

Y地址选通（列选通）

- Y通电导致$T_7, T_8$门控管被打开（饱和导通状态）
- A点与I/O相连

#### 基本读写过程

写过程

X有效→ T5、 T6 通→ A与 I/O 连通

Y有效→ T7、 T8 通 → B与$\overline{I / O}$连通

假定I/O端是高电平，$\overline{I / O}$是低电平，写入的是1，当X，Y都有效时，A点是高电位。
A点是高电位，T1饱和导通，Vss接地，所以B通过T2接地。所以T1是低点位，不饱和导通，维持A点高电位。

写入的是0则相反。

读过程

X有效→ T5、 T6 通→ A与 I/O 连通 1

Y有效→ T7、 T8 通 → B与 $\overline{I / O}$ 连通 0

通过外接于I/O与$\overline{I / O}$间的电流放大器中的电流方向可判断读出的是1还是0(与写入时定义的1和0有关)

如果写入的是0，X，Y有效时，A点低电平，B点高电平
如果写入的是1，X，Y有效时，B点低电平，A点高电平

**无论是读写，X，Y译码线必须同时有效**

#### 保持的工作原理

X、 Y撤销后，由负载管 T3、 T4 分别为工作管T1、 T2 提供工作电流，保持其稳定互锁状态不变。
T2饱和导通，T4为它提供工作电流。T1同理。

### 静态存储器的结构

#### 单译码结构

![img](https://s1.ax1x.com/2020/04/29/JoeCp6.png)

N位地址，寻址$2^n$个存储单元，2n根译码线

#### 双译码结构

![img](https://s1.ax1x.com/2020/04/29/JoeE0H.png)

N位地址，寻址$2^n$个存储单元，$2^{2(n/2)+1}$根译码线

由于每行每列有多个单元，实际应用中，地址译码器输出后面加驱动放大电路。

双译码结构的好处：减少地址译码线的输出数量

举例：双译码存储器

![img](https://s1.ax1x.com/2020/04/30/JLgW9K.png)

具体的存储芯片

![img](https://s1.ax1x.com/2020/04/29/JoetNn.png)

- 地址线 11根，2K存储空间
- 数据线 $D_0 - D_7$，每个单元8位数据
- 读写控制线$\overline{WE}$, $\overline{OE}$均为低电平有效
- 片选信号 低电平有效（用于存储器的扩展）
- 电源线 GND、$V_{DD}$
- 无法知道行列地址多少位

![img](https://s1.ax1x.com/2020/04/30/JL2Q4x.png)

- 地址线 10根，1K存储空间
- 数据线 每个单元4位数据
- 读写控制线 $\overline{WE}$均为低电平写操作，反之读操作
- 片选信号 低电平有效（用于存储器的扩展）
- 电源线 GND、$V_{DD}$
- 无法知道行列地址多少位

2114内部结构图

![img](https://s1.ax1x.com/2020/04/29/Joed3V.png)

列选通有四位，就可也表示2的4次方=16列。相当于第一列物理地址的编号是0000，第二列物理地址的编号是0001……

## 动态存储器工作原理

### SRAM存储单元的不足

- 晶体管数量过多，一个存储单元就要6个晶体管
- 存储密度低，晶体管数量多，存储器难以做大
- 功耗大，无论保存的是0还是1，都有两个晶体管处在饱和导通状态。饱和导通电流较大，功耗较大，热效应明显。

所以静态存储器芯片容量较小。

### DRAM存储单元的基本结构

![img](https://s1.ax1x.com/2020/04/30/JLhdOS.png)

解决SRAM不足采取的方法：

- 去掉两个负载管T3、T4
  - 提升存储密度
  - 降低功耗
  - 降低成本
- 利用栅极分布电容缓存电荷
- 增加电路协同存储单元工作

### 动态存储单元写操作

Y地址选通

- T7，T8管导通
- I/O端数据写入到位线

X地址选通

- T5，T6管导通
- 位线相连与C2相连

假定I/O端为高电平，写入1，A点饱和导通同时还给C2充电。

![img](https://s1.ax1x.com/2020/04/30/JL4yHe.png)

### 动态存储单元读操作

C2上的电量太少，不足以判断写入的数据。所以不能采用静态的方法。

给出预充信号

- T9、T10导通
- 充电电压给CD充电（充满）

撤除预充信号

X地址选通

- T5、T6管导通
- 右CD通过C1放电
- 左CD给C2充电

Y地址选通

- T7、T8管导通
- 左CD 与右CD间形成放电电流

![img](https://s1.ax1x.com/2020/04/30/JL5daQ.png)

读过程比写复杂、速度慢

### 动态存储单元保持操作

- X地址选通信号撤销
- Y地址选通信号撤

由于没有T3，T4，稳定的状态只能由C1，C2来维持，但只能维持几毫秒，所以必须尽快充电防止信息消失。

![img](https://s1.ax1x.com/2020/04/30/JLI5Tg.png)

- 刷新周期：两次刷新之间的时间间隔
- 双译码结构的DRAM刷新按行进行，需要知道RDAM芯片存储矩阵的行数
- 刷新操作是一次不完整的读操作
- 刷新地址由刷新地址计数器给出

### 动态存储单元刷新操作

给出预充信号

- T9，T10导通
- 充电电压给左右CD充电

撤除预充信号

X地址选通

- T5、T6管导通
- 右CD通过C1放电
- 左CD给C2充电

![img](https://s1.ax1x.com/2020/04/30/JLITYj.png)

### 动态存储单元刷新操作

假定刷新周期为2ms, DRAM 内部128行，读写周期0.5µs

#### 集中刷新

![img](https://s1.ax1x.com/2020/04/30/JLoWC9.png)

集中刷新期间，CPU不能访问存储器，否则会导致相关行的内容丢失。

采用集中刷新的存储器平均读写周期 $\overline{T} = 2ms/(4000-128) = 0.5165 \mu s$ 

集中刷新可以保持存储单体的高速特性

#### 分散刷新

![img](https://s1.ax1x.com/2020/04/30/JLTGx1.png)

读写周期由$0.5 \mu s$变成$0.1 \mu s$

$\overline{T} = 1 \mu s$

分散刷新没有保持存储单体的高速特性，由于刷新次数2000大于需要刷新的次数128。

#### 异步刷新

![img](https://s1.ax1x.com/2020/04/30/JLTXoF.png)

将2ms分成128段，每段约$15.5 \mu s$，每段用最后一块刷新。

$\overline{T} = 2ms/(4000-128) = 0.5165 \mu s$ 

### DRAM与SRAM的对比

![img](https://s1.ax1x.com/2020/04/30/JL7GFg.png)

动态读写单元行选通和列选通分开了，因为刷新按照行刷新不需要列选通。

数据的入和出是两个不同的引脚

DRAM: 地址线复用，$\overline{RAS}$兼为片选信号

### 其他结构的DRAM存储单元

进一步提高密度，剪裁冗余电路，核心是电容

![img](https://s1.ax1x.com/2020/05/01/JLbWdK.png)

## 存储扩展

### 存储扩展的基本概念及类型

![img](https://s1.ax1x.com/2020/05/01/JLqJYD.png)

无论哪种类型的存储扩展都要完成CPU与主存间地址线、数据线、控制线的连接

### 位扩展举例

例1 用$16K \times 8$芯片构建$16K \times 32$的存储器

所需芯片数量：16K*32/(16K *8) =4

![img](https://s1.ax1x.com/2020/05/01/JLLP9e.png)

所有存储芯片并行工作，贡献32位数据中的不同8位

### 字扩展举例

例2 用$16K \times 8$的存储芯片构建$128K \times 8$的存储器

所需芯片数量：128K * 8/ (16K*8) = 8

![img](https://s1.ax1x.com/2020/05/01/JjCQij.png)

计算每片的全局地址空间

![img](https://s1.ax1x.com/2020/05/01/JjP9XV.png)

### 字扩展举例

例3 用$16K \times 8$的存储芯片构建$128K \times 8$的存储器，其中08000H~0BFFFH存储空间保留不用

![JjiUPJ.png](https://s1.ax1x.com/2020/05/01/JjiUPJ.png)

![JjifxI.png](https://s1.ax1x.com/2020/05/01/JjifxI.png)

所需芯片数量：（128K-16K）*8/（16K * 8）= 7

![JjiORs.png](https://s1.ax1x.com/2020/05/01/JjiORs.png)

### 字位扩展举例

例4 用$16K \times 8$ 的存储芯片构建$128K \times 32$的存储器

![JjV9XR.png](https://s1.ax1x.com/2020/05/01/JjV9XR.png)

## 多体交叉存储器

### 多体交叉存储器的提出背景

其基本思想是在不提高存储器速率、不扩展数据通路位数的前提下，通过存储芯片的交叉组织，提高CPU单位时间内访问的数据量，从而缓解快速的CPU与慢速的主存之间的速度差异。

### 高位多体交叉存储器的组织方式

![YZdikV.png](https://s1.ax1x.com/2020/05/07/YZdikV.png)

由图中可知，内存地址一共五个bit，一共有四个存储芯片，每一个存储芯片的容量是八个存储单元。由于$2^3=8$，所以，需要三个bit就能表示八个不同的位置。剩下两个bit正好做片选信号。$2^2=4$两个bit表示四种状态正好对应四个存储芯片。

![Ynnnpt.png](https://s1.ax1x.com/2020/05/08/Ynnnpt.png)

这种方式有几个特点：

- 数据组织特点：相邻地址的数据处于同一存储体
- 只有一个地址寄存器
- 多模块串行（局部性原理），几个模块是串行连接在一起的
- 性能无提升。若要访问一段的连续的数据，则只能等一个存储芯片访问完了，才能进行下一个芯片里面的访问。
- 但是扩充容量很方便，直接再后面加一条就行了

### 低位多体交叉存储器的组织方式

![YKvFqx.png](https://s1.ax1x.com/2020/05/08/YKvFqx.png)

与高位不同的是，它采用高位三位表示地址，低2位做片选信号。

![YMCQyQ.png](https://s1.ax1x.com/2020/05/08/YMCQyQ.png)

这样的话000000在第一个芯片， 000001就在第二个芯片。

这种方式的特点是：

- 相邻地址处于不同存储体中
- 每个存储体均需地址寄存器
- 多模块并行(局部性原理)
- 性能提升，若要访问连续的内存，可以同时开四个芯片，并行访问。
- 扩充容量也方便

低位多体交叉存储器得为每一个单体配置单独地址寄存器

![YMk48P.png](https://s1.ax1x.com/2020/05/08/YMk48P.png)

送完第一个数据的地址，可以接着送第二个数据的地址（在第二片上）。等到第四个地址送完后，第一个数据的地址存储访问也已经完成，然后就依次取第一个数据，第二个等等。

定量分析：

设，存储周期为T，总线传输周期（CPU把地址传到每一个芯片的AR的传输周期为$\tau$），多体交叉的模块数量为m个。流水线方式存取的条件：$T=m \tau$

只有满足上述关系，才能实现流水线的并行工作。即每个模块启动后经过 $\tau$ 时间的延时，就可以启动下一个模块。

![Y1vmQg.png](https://s1.ax1x.com/2020/05/10/Y1vmQg.png)

虽然每一个存储单体的周期没变，但是由于并行原理，单位时间内访问的数据量变大了。计算可知。

连续并行读m个字的时间：$t_1=T+(m-1) \tau$

顺序读m个字的时间：$t_1=Tm$